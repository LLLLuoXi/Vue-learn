<!--
 * @Author: luoxi
 * @LastEditTime: 2022-06-30 17:33:14
 * @LastEditors: your name
 * @Description: 
-->
- [⏰ diff的时机](#-diff的时机)
- [🔄 `_update`函数](#-_update函数)
- [↔️ patch函数的对比流程](#️-patch函数的对比流程)
  - [详细流程：](#详细流程)
- [⚠️ 对开发的影响](#️-对开发的影响)
## ⏰ diff的时机
当组件创建时，以及依赖的属性或数据变化时，会运行一个函数，该函数会做两件事：
- 运行`_render`生成一棵新的虚拟dom树（vnode tree）
- 运行`_update`，传入虚拟dom树的根节点，对新旧两棵树进行对比，最终完成对真实dom的更新
    
    核心代码如下：
    ```js
    // vue构造函数
    function Vue(){
      // ... 其他代码
      var updateComponent = () => {
        this._update(this._render())
      }
      new Watcher(updateComponent);
      // ... 其他代码
    }
    ```
    
    `diff`就发生在`_update`函数的运行过程中
    
## 🔄 `_update`函数
    
`_update`函数接收到一个`vnode`参数，这就是**新**生成的虚拟dom树
    
 同时，`_update`函数通过当前组件的`_vnode`属性，拿到**旧**的虚拟dom树
    
 `_update`函数首先会给组件的`_vnode`属性重新赋值，让它指向新树
    
![diff大致过程1](/assets/diff大致过程1.png)
    
 然后会判断旧树是否存在：
    
 - 不存在：说明这是第一次加载组件，于是通过内部的`patch`函数，直接遍历新树，为每个节点生成真实DOM，挂载到每个节点的`elm`属性上
```js
if (!oldVnode) {
    // 首次渲染会把挂载的真实dom传入，
    // 把新的虚拟节点和dom进入对比，会按照vnode生成新的虚拟don树生成真实dom挂载到this.$el部分
    this.__patch__(this.$el, vnode)
}
```
        
![首次渲染](/assets/首次渲染.png)
        
- 存在：说明之前已经渲染过该组件，于是通过内部的`patch`函数，对新旧两棵树进行对比，以达到下面两个目标：
    -   完成对所有真实dom的最小化处理
    -   让新树的节点对应合适的真实dom
        
![旧树存在](/assets/旧树存在.png)
        
## ↔️ patch函数的对比流程
    
**术语解释**：

1. 「**相同**」：是指两个虚拟节点的标签类型`tag`、`key`值均相同，但`input`元素还要看`type`属性
```js
//<h1>test1</h1>  <h1>test1</h1> 相同
// vnode
{
    tag:'h1',
    key:undefined,
    //...
}
{ 
    tag:'h1',
    key:undefined,
    //...
}
//<h1 key="1">test1</h1>  <h1 key="2">test1</h1> 不相同
// <input type="text"/> <input type="radio"/> 不相同
// test1 test2 相同 文本虚拟节点

```
1. 「**新建元素**」：是指根据一个虚拟节点提供的信息，创建一个真实dom元素，同时挂载到虚拟节点的`elm`属性上
2. 「**销毁元素**」：是指：`vnode.elm.remove()`
3. 「**更新**」：是指对两个虚拟节点进行对比更新，它**仅发生**在两个虚拟节点「相同」的情况下。具体过程稍后描述。
4. 「**对比子节点**」：是指对两个虚拟节点的子节点进行对比，具体过程稍后描述

### 详细流程：

1. **根节点比较**
    
    ![同层比较](/assets/同层比较.png)
    
    `patch`函数首先对根节点进行比较
    
    如果两个节点：
    
    - 「**相同**」，进入「**更新**」流程
        1. 将旧节点的真实dom赋值到新节点：`newVnode.elm = oldVnode.elm`
        2. 对比新节点和旧节点的属性，有变化的更新到真实dom中
        3. 当前两个节点处理完毕，开始「**对比子节点**」
    - 不「**相同**」
        1. 新节点**递归**「**新建元素**」
        2. 旧节点「**销毁元素**」
2. **「对比子节点」**
    会遵循深度优先原则和同层比较原则，也就是不会跨越vnode树的结构去进行比较。
        **双端diff算法**
    -  **双端 diff** 是头尾指针向中间移动的同时，对比头头、尾尾、头尾、尾头是否可以复用，如果可以的话就移动对应的 dom 节点。
    - 如果头尾没找到可复用节点就遍历 vnode 数组来查找，然后移动对应下标的节点到头部。

    - 最后还剩下旧的 vnode 就批量删除，剩下新的 vnode 就批量新增。
    在「**对比子节点**」时，vue一切的出发点，都是为了：
    
    - 尽量啥也别做
    - 不行的话，尽量仅改动元素属性
    - 还不行的话，尽量移动元素，而不是删除和创建元素
    - 还不行的话，删除和创建元素
    


## ⚠️ 对开发的影响
- 循环数组生成虚拟dom或头部插入的时候加上`key`。
- 在使用相同标签名元素的过渡切换时，也要使用`key`，目的是为了让vue区分他们，否则只会进入「**更新**」流程替换其内部的属性而不触发过渡效果。
- 在使用相同input和v-if做切换显示的时，不加`key`vue会认为两个input是同一个节点，从而导致`input`内的值没有消失。
- 。。。。。。。。🖊️